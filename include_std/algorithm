/*
	This file is part of Fennix Kernel.

	Fennix Kernel is free software: you can redistribute it and/or
	modify it under the terms of the GNU General Public License as
	published by the Free Software Foundation, either version 3 of
	the License, or (at your option) any later version.

	Fennix Kernel is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Fennix Kernel. If not, see <https://www.gnu.org/licenses/>.
*/

#pragma once
#include <utility>

namespace std
{
	template <typename InputIt, typename OutputIt>
	OutputIt copy(InputIt first, InputIt last, OutputIt result)
	{
		while (first != last)
		{
			*result = *first;
			++result;
			++first;
		}
		return result;
	}

	template <class BidirIt1, class BidirIt2>
	BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
	{
		while (first != last)
		{
			*(--d_last) = *(--last);
		}
		return d_last;
	}

	template <typename T>
	void swap(T &a, T &b)
	{
		T temp = move(a);
		a = move(b);
		b = move(temp);
	}

	template <typename T>
	constexpr const T &min(const T &a, const T &b)
	{
		return (a < b) ? a : b;
	}

	template <typename T>
	constexpr const T &max(const T &a, const T &b)
	{
		return (a > b) ? a : b;
	}

	template <typename T>
	constexpr const T &clamp(const T &v, const T &lo, const T &hi)
	{
		return std::max(lo, std::min(v, hi));
	}

	template <class T, class Compare>
	constexpr const T &clamp(const T &v, const T &lo, const T &hi, Compare comp)
	{
		return comp(v, lo) ? lo : comp(hi, v) ? hi
											  : v;
	}

	template <class ForwardIt1, class ForwardIt2>
	ForwardIt1 search(ForwardIt1 first, ForwardIt1 last,
					  ForwardIt2 s_first, ForwardIt2 s_last)
	{
		for (; first != last; ++first)
		{
			ForwardIt1 it = first;
			for (ForwardIt2 s_it = s_first;; ++it, ++s_it)
			{
				if (s_it == s_last)
					return first;
				if (it == last)
					return last;
				if (!(*it == *s_it))
					break;
			}
		}
		return last;
	}

	template <class InputIt, class T>
	constexpr InputIt find(InputIt first, InputIt last, const T &value)
	{
		for (; first != last; ++first)
			if (*first == value)
				return first;

		return last;
	}

	template <class InputIt, class UnaryPred>
	constexpr InputIt find_if(InputIt first, InputIt last, UnaryPred p)
	{
		for (; first != last; ++first)
			if (p(*first))
				return first;

		return last;
	}

	template <class InputIt, class UnaryPred>
	constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPred q)
	{
		for (; first != last; ++first)
			if (!q(*first))
				return first;

		return last;
	}

	template <class ForwardIt1, class ForwardIt2>
	ForwardIt1 find_end(ForwardIt1 first, ForwardIt1 last,
						ForwardIt2 s_first, ForwardIt2 s_last)
	{
		if (s_first == s_last)
			return last;
		ForwardIt1 result = last;
		while (true)
		{
			ForwardIt1 new_result = std::search(first, last, s_first, s_last);
			if (new_result == last)
				return result;
			result = new_result;
			first = new_result;
			++first;
		}
	}

	template <class InputIt, class ForwardIt>
	InputIt find_first_of(InputIt first, InputIt last,
						  ForwardIt s_first, ForwardIt s_last)
	{
		for (; first != last; ++first)
			for (ForwardIt it = s_first; it != s_last; ++it)
				if (*first == *it)
					return first;
		return last;
	}

	template <class ForwardIt, class T>
	ForwardIt remove(ForwardIt first, ForwardIt last, const T &value)
	{
		first = std::find(first, last, value);
		if (first != last)
			for (ForwardIt i = first; ++i != last;)
				if (!(*i == value))
					*first++ = std::move(*i);
		return first;
	}

	template <class ForwardIt, class UnaryPred>
	ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPred p)
	{
		first = std::find_if(first, last, p);
		if (first != last)
			for (ForwardIt i = first; ++i != last;)
				if (!p(*i))
					*first++ = std::move(*i);
		return first;
	}

	template <class ForwardIt, class T>
	void fill(ForwardIt first, ForwardIt last, const T &value)
	{
		for (; first != last; ++first)
			*first = value;
	}

	template <class OutputIt, class Size, class T>
	OutputIt fill_n(OutputIt first, Size count, const T &value)
	{
		for (Size i = 0; i < count; ++i)
		{
			*first = value;
			++first;
		}
		return first;
	}
}
